---
title: 0.1 + 0.2 != 0.3
date: 2022-09-02 12:10:02
description: JS 中数值的二进制表示
categories:
- JavaScript
tags:
- JavaScript
---

***

<b><font color="#dd00dd" size=6>0.1+0.2 != 0.3</font></b>

***

**产生原因**

在 **`JS`** 语言中，`0.1` 和 `0.2` 都转化成二进制后再进行运算，某些十进制的浮点数在转换为二进制数时会出现无限循环，造成二进制的舍入操作（`0`舍`1`入），当再转换为十进制时就造成了计算误差

首先 `0.1` 二进制表示 **`0.000110011...`** 后面 **`0011`** 无限循环，无法精确保存类似 `0.1` 这样的小数

在 `JS` 中不论小数还是整数只有一种数据类型表示，这就是 `Number` 类型

遵循 **`IEEE 754`** 标准，使用双精度浮点数（`double`）`64`位（`8`字节）来存储一个浮点数

**这 `64Bits` 分为`3`个部分：**
- `sign bit`**（`S` 符号）**：用来表示正负号，**0 为 正 ，1 为 负**（`1 bit`）
- `exponent`**（`E` 指数）**：用来表示次方数（`11 bits`）**（固定偏移量为 <font color="#ddoodd">`1023`</font>）**
- `mantissa`**（`M` 尾数）**：用来表示精确度（`52 bits`）第 `1` 位总为 `1` 并舍去，保存 `1.01 → 01`

**`2`进制表示：**<br />

**`0.1`**：<br />**`1.100110011... * 2^-4`  `S`正数取`0`，`E`取`-4+1023 = 1019`，`M`取小数部分`100110011...`**

**`0.2`：**<br />**`1.100110011... * 2^-3`  `S`正数取`0`，`E`取`-3+1023 = 1020`，`M`取小数部分`100110011...`**

```javascript
S  E            M
0  01111111011  1001100110011001100110011001100110011001100110011010 // 0.1
0  01111111100  1001100110011001100110011001100110011001100110011010 // 0.2

// 0.1 和 0.2 转化成二进制进行运算, 结果转成十进制为是 0.30000000000000004
0.0001100110011001100110011001100110011001100110011001101 +
0.0011001100110011001100110011001100110011001100110011010 =
0.0100110011001100110011001100110011001100110011001100111
```
**数值`1.1111111111111111111111111111111111111111111111111111 * 2^52` `(2^53-1)`**<br />**这是能精确表示的最大的数吗？大概！`9007199254740991`**

**好像 `2^53` `→` `9007199254740992` 也能精确表示**<br />**数值 `2^53` `→` `1.0000000000000000000000000000000000000000000000000000 * 2^53` （<font color="#dd00dd">52个0</font>）是可以精确表示的**

**但是 `2^53 + 1` 就不行了（因为最多只能有 `52` 位小数点之后的数）**<br />**超过 `2^53` `9007199254740992` 的数的精度会丢失**

- **（2^53, 2^54）之间的数只能精确表示其中的<font color="#dd00dd">偶数</font>**
- **1.000000000000000000000000000000000000000000000000001 * 2^53 = 2^53 + 2 的值如下**
- **1000000000000000000000000000000000000000000000000001<font color="#dd00dd">0</font> = 2^53 + 2 可以精确表示**
- **1000000000000000000000000000000000000000000000000001<font color="#dd00dd">1</font> = 2^53 + 3 无法精确表示**
- **（2^54, 2^55）只能精确表示其中的`4`的倍数<font color="#dd00dd">（紫色末尾数字为52位后补的数字，实际上表达不出，所以只可补0）</font>**
- **（2^55, 2^56）只能精确表示其中的`8`的倍数 ......**

**为什么为某个变量赋值时可以得到 `0.1`**

最大可精确表示数 **`9007199254740992`，**对应科学计数尾数是 **`9.007199254740992`，**这也是 `JS` 最多能表示的精度，长度为 `16`，`JS` 自动使用了 **`toPrecision(16)`** 来做精度运算

所以看到的 `0.1` 其实不是 `0.1`，是被做了精度运算之后的值

**注：`1.111111.toPrecision(5) = 1.1111` | `0.111111.toPrecision(5) = 0.11111`**

```javascript
0.10000000000000000555.toPrecision(16) 	// 0.1000000000000000 末尾零去掉，最终为 0.1

0.1.toPrecision(22)											// 0.1000000000000000055511
```
**其他**

```javascript
// 加法
0.1 + 0.2 = 0.30000000000000004
0.7 + 0.1 = 0.7999999999999999
0.2 + 0.4 = 0.6000000000000001

// 减法
1.5 - 1.2 = 0.30000000000000004
0.3 - 0.2 = 0.09999999999999998
 
// 乘法
35.41 * 100 = 3540.9999999999995
19.9 * 100 = 1989.9999999999998
0.8 * 3 = 2.4000000000000004

// 除法
0.3 / 0.1 = 2.9999999999999996
0.69 / 10 = 0.06899999999999999
```
[**MORE**](https://zhuanlan.zhihu.com/p/103254614)

[**MORE**](https://zhuanlan.zhihu.com/p/100353781)